import * as $protobuf from "@apollo/protobufjs";
/** Properties of a Trace. */
export interface ITrace {

    /** Trace startTime */
    startTime?: (google.protobuf.ITimestamp|null);

    /** Trace endTime */
    endTime?: (google.protobuf.ITimestamp|null);

    /** Trace durationNs */
    durationNs?: (number|null);

    /** Trace root */
    root?: (Trace.INode|null);

    /** Trace signature */
    signature?: (string|null);

    /** Trace unexecutedOperationBody */
    unexecutedOperationBody?: (string|null);

    /** Trace unexecutedOperationName */
    unexecutedOperationName?: (string|null);

    /** Trace details */
    details?: (Trace.IDetails|null);

    /** Trace clientName */
    clientName?: (string|null);

    /** Trace clientVersion */
    clientVersion?: (string|null);

    /** Trace clientAddress */
    clientAddress?: (string|null);

    /** Trace clientReferenceId */
    clientReferenceId?: (string|null);

    /** Trace http */
    http?: (Trace.IHTTP|null);

    /** Trace cachePolicy */
    cachePolicy?: (Trace.ICachePolicy|null);

    /** Trace queryPlan */
    queryPlan?: (Trace.IQueryPlanNode|null);

    /** Trace fullQueryCacheHit */
    fullQueryCacheHit?: (boolean|null);

    /** Trace persistedQueryHit */
    persistedQueryHit?: (boolean|null);

    /** Trace persistedQueryRegister */
    persistedQueryRegister?: (boolean|null);

    /** Trace registeredOperation */
    registeredOperation?: (boolean|null);

    /** Trace forbiddenOperation */
    forbiddenOperation?: (boolean|null);
}

/** Represents a Trace. */
export class Trace implements ITrace {

    /**
     * Constructs a new Trace.
     * @param [properties] Properties to set
     */
    constructor(properties?: ITrace);

    /** Trace startTime. */
    public startTime?: (google.protobuf.ITimestamp|null);

    /** Trace endTime. */
    public endTime?: (google.protobuf.ITimestamp|null);

    /** Trace durationNs. */
    public durationNs: number;

    /** Trace root. */
    public root?: (Trace.INode|null);

    /** Trace signature. */
    public signature: string;

    /** Trace unexecutedOperationBody. */
    public unexecutedOperationBody: string;

    /** Trace unexecutedOperationName. */
    public unexecutedOperationName: string;

    /** Trace details. */
    public details?: (Trace.IDetails|null);

    /** Trace clientName. */
    public clientName: string;

    /** Trace clientVersion. */
    public clientVersion: string;

    /** Trace clientAddress. */
    public clientAddress: string;

    /** Trace clientReferenceId. */
    public clientReferenceId: string;

    /** Trace http. */
    public http?: (Trace.IHTTP|null);

    /** Trace cachePolicy. */
    public cachePolicy?: (Trace.ICachePolicy|null);

    /** Trace queryPlan. */
    public queryPlan?: (Trace.IQueryPlanNode|null);

    /** Trace fullQueryCacheHit. */
    public fullQueryCacheHit: boolean;

    /** Trace persistedQueryHit. */
    public persistedQueryHit: boolean;

    /** Trace persistedQueryRegister. */
    public persistedQueryRegister: boolean;

    /** Trace registeredOperation. */
    public registeredOperation: boolean;

    /** Trace forbiddenOperation. */
    public forbiddenOperation: boolean;

    /**
     * Creates a new Trace instance using the specified properties.
     * @param [properties] Properties to set
     * @returns Trace instance
     */
    public static create(properties?: ITrace): Trace;

    /**
     * Encodes the specified Trace message. Does not implicitly {@link Trace.verify|verify} messages.
     * @param message Trace message or plain object to encode
     * @param [writer] Writer to encode to
     * @returns Writer
     */
    public static encode(message: ITrace, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified Trace message, length delimited. Does not implicitly {@link Trace.verify|verify} messages.
     * @param message Trace message or plain object to encode
     * @param [writer] Writer to encode to
     * @returns Writer
     */
    public static encodeDelimited(message: ITrace, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a Trace message from the specified reader or buffer.
     * @param reader Reader or buffer to decode from
     * @param [length] Message length if known beforehand
     * @returns Trace
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace;

    /**
     * Decodes a Trace message from the specified reader or buffer, length delimited.
     * @param reader Reader or buffer to decode from
     * @returns Trace
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace;

    /**
     * Verifies a Trace message.
     * @param message Plain object to verify
     * @returns `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): (string|null);

    /**
     * Creates a plain object from a Trace message. Also converts values to other types if specified.
     * @param message Trace
     * @param [options] Conversion options
     * @returns Plain object
     */
    public static toObject(message: Trace, options?: $protobuf.IConversionOptions): { [k: string]: any };

    /**
     * Converts this Trace to JSON.
     * @returns JSON object
     */
    public toJSON(): { [k: string]: any };
}

export namespace Trace {

    /** Properties of a CachePolicy. */
    interface ICachePolicy {

        /** CachePolicy scope */
        scope?: (Trace.CachePolicy.Scope|null);

        /** CachePolicy maxAgeNs */
        maxAgeNs?: (number|null);
    }

    /** Represents a CachePolicy. */
    class CachePolicy implements ICachePolicy {

        /**
         * Constructs a new CachePolicy.
         * @param [properties] Properties to set
         */
        constructor(properties?: Trace.ICachePolicy);

        /** CachePolicy scope. */
        public scope: Trace.CachePolicy.Scope;

        /** CachePolicy maxAgeNs. */
        public maxAgeNs: number;

        /**
         * Creates a new CachePolicy instance using the specified properties.
         * @param [properties] Properties to set
         * @returns CachePolicy instance
         */
        public static create(properties?: Trace.ICachePolicy): Trace.CachePolicy;

        /**
         * Encodes the specified CachePolicy message. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.
         * @param message CachePolicy message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: Trace.ICachePolicy, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified CachePolicy message, length delimited. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.
         * @param message CachePolicy message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: Trace.ICachePolicy, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a CachePolicy message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns CachePolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.CachePolicy;

        /**
         * Decodes a CachePolicy message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns CachePolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.CachePolicy;

        /**
         * Verifies a CachePolicy message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a plain object from a CachePolicy message. Also converts values to other types if specified.
         * @param message CachePolicy
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: Trace.CachePolicy, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this CachePolicy to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace CachePolicy {

        /** Scope enum. */
        enum Scope {
            UNKNOWN = 0,
            PUBLIC = 1,
            PRIVATE = 2
        }
    }

    /** Properties of a Details. */
    interface IDetails {

        /** Details variablesJson */
        variablesJson?: ({ [k: string]: string }|null);

        /** Details operationName */
        operationName?: (string|null);
    }

    /** Represents a Details. */
    class Details implements IDetails {

        /**
         * Constructs a new Details.
         * @param [properties] Properties to set
         */
        constructor(properties?: Trace.IDetails);

        /** Details variablesJson. */
        public variablesJson: { [k: string]: string };

        /** Details operationName. */
        public operationName: string;

        /**
         * Creates a new Details instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Details instance
         */
        public static create(properties?: Trace.IDetails): Trace.Details;

        /**
         * Encodes the specified Details message. Does not implicitly {@link Trace.Details.verify|verify} messages.
         * @param message Details message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: Trace.IDetails, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Details message, length delimited. Does not implicitly {@link Trace.Details.verify|verify} messages.
         * @param message Details message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: Trace.IDetails, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Details message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Details
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.Details;

        /**
         * Decodes a Details message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Details
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.Details;

        /**
         * Verifies a Details message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a plain object from a Details message. Also converts values to other types if specified.
         * @param message Details
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: Trace.Details, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Details to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of an Error. */
    interface IError {

        /** Error message */
        message?: (string|null);

        /** Error location */
        location?: (Trace.ILocation[]|null);

        /** Error timeNs */
        timeNs?: (number|null);

        /** Error json */
        json?: (string|null);
    }

    /** Represents an Error. */
    class Error implements IError {

        /**
         * Constructs a new Error.
         * @param [properties] Properties to set
         */
        constructor(properties?: Trace.IError);

        /** Error message. */
        public message: string;

        /** Error location. */
        public location: Trace.ILocation[];

        /** Error timeNs. */
        public timeNs: number;

        /** Error json. */
        public json: string;

        /**
         * Creates a new Error instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Error instance
         */
        public static create(properties?: Trace.IError): Trace.Error;

        /**
         * Encodes the specified Error message. Does not implicitly {@link Trace.Error.verify|verify} messages.
         * @param message Error message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: Trace.IError, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Error message, length delimited. Does not implicitly {@link Trace.Error.verify|verify} messages.
         * @param message Error message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: Trace.IError, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes an Error message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.Error;

        /**
         * Decodes an Error message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Error
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.Error;

        /**
         * Verifies an Error message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a plain object from an Error message. Also converts values to other types if specified.
         * @param message Error
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: Trace.Error, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Error to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a HTTP. */
    interface IHTTP {

        /** HTTP method */
        method?: (Trace.HTTP.Method|null);

        /** HTTP host */
        host?: (string|null);

        /** HTTP path */
        path?: (string|null);

        /** HTTP requestHeaders */
        requestHeaders?: ({ [k: string]: Trace.HTTP.IValues }|null);

        /** HTTP responseHeaders */
        responseHeaders?: ({ [k: string]: Trace.HTTP.IValues }|null);

        /** HTTP statusCode */
        statusCode?: (number|null);

        /** HTTP secure */
        secure?: (boolean|null);

        /** HTTP protocol */
        protocol?: (string|null);
    }

    /** Represents a HTTP. */
    class HTTP implements IHTTP {

        /**
         * Constructs a new HTTP.
         * @param [properties] Properties to set
         */
        constructor(properties?: Trace.IHTTP);

        /** HTTP method. */
        public method: Trace.HTTP.Method;

        /** HTTP host. */
        public host: string;

        /** HTTP path. */
        public path: string;

        /** HTTP requestHeaders. */
        public requestHeaders: { [k: string]: Trace.HTTP.IValues };

        /** HTTP responseHeaders. */
        public responseHeaders: { [k: string]: Trace.HTTP.IValues };

        /** HTTP statusCode. */
        public statusCode: number;

        /** HTTP secure. */
        public secure: boolean;

        /** HTTP protocol. */
        public protocol: string;

        /**
         * Creates a new HTTP instance using the specified properties.
         * @param [properties] Properties to set
         * @returns HTTP instance
         */
        public static create(properties?: Trace.IHTTP): Trace.HTTP;

        /**
         * Encodes the specified HTTP message. Does not implicitly {@link Trace.HTTP.verify|verify} messages.
         * @param message HTTP message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: Trace.IHTTP, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified HTTP message, length delimited. Does not implicitly {@link Trace.HTTP.verify|verify} messages.
         * @param message HTTP message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: Trace.IHTTP, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a HTTP message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns HTTP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.HTTP;

        /**
         * Decodes a HTTP message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns HTTP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.HTTP;

        /**
         * Verifies a HTTP message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a plain object from a HTTP message. Also converts values to other types if specified.
         * @param message HTTP
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: Trace.HTTP, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this HTTP to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace HTTP {

        /** Properties of a Values. */
        interface IValues {

            /** Values value */
            value?: (string[]|null);
        }

        /** Represents a Values. */
        class Values implements IValues {

            /**
             * Constructs a new Values.
             * @param [properties] Properties to set
             */
            constructor(properties?: Trace.HTTP.IValues);

            /** Values value. */
            public value: string[];

            /**
             * Creates a new Values instance using the specified properties.
             * @param [properties] Properties to set
             * @returns Values instance
             */
            public static create(properties?: Trace.HTTP.IValues): Trace.HTTP.Values;

            /**
             * Encodes the specified Values message. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.
             * @param message Values message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encode(message: Trace.HTTP.IValues, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified Values message, length delimited. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.
             * @param message Values message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encodeDelimited(message: Trace.HTTP.IValues, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a Values message from the specified reader or buffer.
             * @param reader Reader or buffer to decode from
             * @param [length] Message length if known beforehand
             * @returns Values
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.HTTP.Values;

            /**
             * Decodes a Values message from the specified reader or buffer, length delimited.
             * @param reader Reader or buffer to decode from
             * @returns Values
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.HTTP.Values;

            /**
             * Verifies a Values message.
             * @param message Plain object to verify
             * @returns `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a plain object from a Values message. Also converts values to other types if specified.
             * @param message Values
             * @param [options] Conversion options
             * @returns Plain object
             */
            public static toObject(message: Trace.HTTP.Values, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Converts this Values to JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Method enum. */
        enum Method {
            UNKNOWN = 0,
            OPTIONS = 1,
            GET = 2,
            HEAD = 3,
            POST = 4,
            PUT = 5,
            DELETE = 6,
            TRACE = 7,
            CONNECT = 8,
            PATCH = 9
        }
    }

    /** Properties of a Location. */
    interface ILocation {

        /** Location line */
        line?: (number|null);

        /** Location column */
        column?: (number|null);
    }

    /** Represents a Location. */
    class Location implements ILocation {

        /**
         * Constructs a new Location.
         * @param [properties] Properties to set
         */
        constructor(properties?: Trace.ILocation);

        /** Location line. */
        public line: number;

        /** Location column. */
        public column: number;

        /**
         * Creates a new Location instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Location instance
         */
        public static create(properties?: Trace.ILocation): Trace.Location;

        /**
         * Encodes the specified Location message. Does not implicitly {@link Trace.Location.verify|verify} messages.
         * @param message Location message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: Trace.ILocation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Location message, length delimited. Does not implicitly {@link Trace.Location.verify|verify} messages.
         * @param message Location message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: Trace.ILocation, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Location message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.Location;

        /**
         * Decodes a Location message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Location
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.Location;

        /**
         * Verifies a Location message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a plain object from a Location message. Also converts values to other types if specified.
         * @param message Location
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: Trace.Location, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Location to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a Node. */
    interface INode {

        /** Node responseName */
        responseName?: (string|null);

        /** Node index */
        index?: (number|null);

        /** Node originalFieldName */
        originalFieldName?: (string|null);

        /** Node type */
        type?: (string|null);

        /** Node parentType */
        parentType?: (string|null);

        /** Node cachePolicy */
        cachePolicy?: (Trace.ICachePolicy|null);

        /** Node startTime */
        startTime?: (number|null);

        /** Node endTime */
        endTime?: (number|null);

        /** Node error */
        error?: (Trace.IError[]|null);

        /** Node child */
        child?: (Trace.INode[]|null);
    }

    /** Represents a Node. */
    class Node implements INode {

        /**
         * Constructs a new Node.
         * @param [properties] Properties to set
         */
        constructor(properties?: Trace.INode);

        /** Node responseName. */
        public responseName: string;

        /** Node index. */
        public index: number;

        /** Node originalFieldName. */
        public originalFieldName: string;

        /** Node type. */
        public type: string;

        /** Node parentType. */
        public parentType: string;

        /** Node cachePolicy. */
        public cachePolicy?: (Trace.ICachePolicy|null);

        /** Node startTime. */
        public startTime: number;

        /** Node endTime. */
        public endTime: number;

        /** Node error. */
        public error: Trace.IError[];

        /** Node child. */
        public child: Trace.INode[];

        /** Node id. */
        public id?: ("responseName"|"index");

        /**
         * Creates a new Node instance using the specified properties.
         * @param [properties] Properties to set
         * @returns Node instance
         */
        public static create(properties?: Trace.INode): Trace.Node;

        /**
         * Encodes the specified Node message. Does not implicitly {@link Trace.Node.verify|verify} messages.
         * @param message Node message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: Trace.INode, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified Node message, length delimited. Does not implicitly {@link Trace.Node.verify|verify} messages.
         * @param message Node message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: Trace.INode, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a Node message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns Node
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.Node;

        /**
         * Decodes a Node message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns Node
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.Node;

        /**
         * Verifies a Node message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a plain object from a Node message. Also converts values to other types if specified.
         * @param message Node
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: Trace.Node, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this Node to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    /** Properties of a QueryPlanNode. */
    interface IQueryPlanNode {

        /** QueryPlanNode sequence */
        sequence?: (Trace.QueryPlanNode.ISequenceNode|null);

        /** QueryPlanNode parallel */
        parallel?: (Trace.QueryPlanNode.IParallelNode|null);

        /** QueryPlanNode fetch */
        fetch?: (Trace.QueryPlanNode.IFetchNode|null);

        /** QueryPlanNode flatten */
        flatten?: (Trace.QueryPlanNode.IFlattenNode|null);
    }

    /** Represents a QueryPlanNode. */
    class QueryPlanNode implements IQueryPlanNode {

        /**
         * Constructs a new QueryPlanNode.
         * @param [properties] Properties to set
         */
        constructor(properties?: Trace.IQueryPlanNode);

        /** QueryPlanNode sequence. */
        public sequence?: (Trace.QueryPlanNode.ISequenceNode|null);

        /** QueryPlanNode parallel. */
        public parallel?: (Trace.QueryPlanNode.IParallelNode|null);

        /** QueryPlanNode fetch. */
        public fetch?: (Trace.QueryPlanNode.IFetchNode|null);

        /** QueryPlanNode flatten. */
        public flatten?: (Trace.QueryPlanNode.IFlattenNode|null);

        /** QueryPlanNode node. */
        public node?: ("sequence"|"parallel"|"fetch"|"flatten");

        /**
         * Creates a new QueryPlanNode instance using the specified properties.
         * @param [properties] Properties to set
         * @returns QueryPlanNode instance
         */
        public static create(properties?: Trace.IQueryPlanNode): Trace.QueryPlanNode;

        /**
         * Encodes the specified QueryPlanNode message. Does not implicitly {@link Trace.QueryPlanNode.verify|verify} messages.
         * @param message QueryPlanNode message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encode(message: Trace.IQueryPlanNode, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Encodes the specified QueryPlanNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.verify|verify} messages.
         * @param message QueryPlanNode message or plain object to encode
         * @param [writer] Writer to encode to
         * @returns Writer
         */
        public static encodeDelimited(message: Trace.IQueryPlanNode, writer?: $protobuf.Writer): $protobuf.Writer;

        /**
         * Decodes a QueryPlanNode message from the specified reader or buffer.
         * @param reader Reader or buffer to decode from
         * @param [length] Message length if known beforehand
         * @returns QueryPlanNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.QueryPlanNode;

        /**
         * Decodes a QueryPlanNode message from the specified reader or buffer, length delimited.
         * @param reader Reader or buffer to decode from
         * @returns QueryPlanNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.QueryPlanNode;

        /**
         * Verifies a QueryPlanNode message.
         * @param message Plain object to verify
         * @returns `null` if valid, otherwise the reason why it is not
         */
        public static verify(message: { [k: string]: any }): (string|null);

        /**
         * Creates a plain object from a QueryPlanNode message. Also converts values to other types if specified.
         * @param message QueryPlanNode
         * @param [options] Conversion options
         * @returns Plain object
         */
        public static toObject(message: Trace.QueryPlanNode, options?: $protobuf.IConversionOptions): { [k: string]: any };

        /**
         * Converts this QueryPlanNode to JSON.
         * @returns JSON object
         */
        public toJSON(): { [k: string]: any };
    }

    namespace QueryPlanNode {

        /** Properties of a SequenceNode. */
        interface ISequenceNode {

            /** SequenceNode nodes */
            nodes?: (Trace.IQueryPlanNode[]|null);
        }

        /** Represents a SequenceNode. */
        class SequenceNode implements ISequenceNode {

            /**
             * Constructs a new SequenceNode.
             * @param [properties] Properties to set
             */
            constructor(properties?: Trace.QueryPlanNode.ISequenceNode);

            /** SequenceNode nodes. */
            public nodes: Trace.IQueryPlanNode[];

            /**
             * Creates a new SequenceNode instance using the specified properties.
             * @param [properties] Properties to set
             * @returns SequenceNode instance
             */
            public static create(properties?: Trace.QueryPlanNode.ISequenceNode): Trace.QueryPlanNode.SequenceNode;

            /**
             * Encodes the specified SequenceNode message. Does not implicitly {@link Trace.QueryPlanNode.SequenceNode.verify|verify} messages.
             * @param message SequenceNode message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encode(message: Trace.QueryPlanNode.ISequenceNode, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified SequenceNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.SequenceNode.verify|verify} messages.
             * @param message SequenceNode message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encodeDelimited(message: Trace.QueryPlanNode.ISequenceNode, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a SequenceNode message from the specified reader or buffer.
             * @param reader Reader or buffer to decode from
             * @param [length] Message length if known beforehand
             * @returns SequenceNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.QueryPlanNode.SequenceNode;

            /**
             * Decodes a SequenceNode message from the specified reader or buffer, length delimited.
             * @param reader Reader or buffer to decode from
             * @returns SequenceNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.QueryPlanNode.SequenceNode;

            /**
             * Verifies a SequenceNode message.
             * @param message Plain object to verify
             * @returns `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a plain object from a SequenceNode message. Also converts values to other types if specified.
             * @param message SequenceNode
             * @param [options] Conversion options
             * @returns Plain object
             */
            public static toObject(message: Trace.QueryPlanNode.SequenceNode, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Converts this SequenceNode to JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Properties of a ParallelNode. */
        interface IParallelNode {

            /** ParallelNode nodes */
            nodes?: (Trace.IQueryPlanNode[]|null);
        }

        /** Represents a ParallelNode. */
        class ParallelNode implements IParallelNode {

            /**
             * Constructs a new ParallelNode.
             * @param [properties] Properties to set
             */
            constructor(properties?: Trace.QueryPlanNode.IParallelNode);

            /** ParallelNode nodes. */
            public nodes: Trace.IQueryPlanNode[];

            /**
             * Creates a new ParallelNode instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ParallelNode instance
             */
            public static create(properties?: Trace.QueryPlanNode.IParallelNode): Trace.QueryPlanNode.ParallelNode;

            /**
             * Encodes the specified ParallelNode message. Does not implicitly {@link Trace.QueryPlanNode.ParallelNode.verify|verify} messages.
             * @param message ParallelNode message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encode(message: Trace.QueryPlanNode.IParallelNode, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ParallelNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ParallelNode.verify|verify} messages.
             * @param message ParallelNode message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encodeDelimited(message: Trace.QueryPlanNode.IParallelNode, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ParallelNode message from the specified reader or buffer.
             * @param reader Reader or buffer to decode from
             * @param [length] Message length if known beforehand
             * @returns ParallelNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.QueryPlanNode.ParallelNode;

            /**
             * Decodes a ParallelNode message from the specified reader or buffer, length delimited.
             * @param reader Reader or buffer to decode from
             * @returns ParallelNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.QueryPlanNode.ParallelNode;

            /**
             * Verifies a ParallelNode message.
             * @param message Plain object to verify
             * @returns `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a plain object from a ParallelNode message. Also converts values to other types if specified.
             * @param message ParallelNode
             * @param [options] Conversion options
             * @returns Plain object
             */
            public static toObject(message: Trace.QueryPlanNode.ParallelNode, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Converts this ParallelNode to JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Properties of a FetchNode. */
        interface IFetchNode {

            /** FetchNode serviceName */
            serviceName?: (string|null);

            /** FetchNode traceParsingFailed */
            traceParsingFailed?: (boolean|null);

            /** FetchNode trace */
            trace?: (ITrace|null);

            /** FetchNode sentTimeOffset */
            sentTimeOffset?: (number|null);

            /** FetchNode sentTime */
            sentTime?: (google.protobuf.ITimestamp|null);

            /** FetchNode receivedTime */
            receivedTime?: (google.protobuf.ITimestamp|null);
        }

        /** Represents a FetchNode. */
        class FetchNode implements IFetchNode {

            /**
             * Constructs a new FetchNode.
             * @param [properties] Properties to set
             */
            constructor(properties?: Trace.QueryPlanNode.IFetchNode);

            /** FetchNode serviceName. */
            public serviceName: string;

            /** FetchNode traceParsingFailed. */
            public traceParsingFailed: boolean;

            /** FetchNode trace. */
            public trace?: (ITrace|null);

            /** FetchNode sentTimeOffset. */
            public sentTimeOffset: number;

            /** FetchNode sentTime. */
            public sentTime?: (google.protobuf.ITimestamp|null);

            /** FetchNode receivedTime. */
            public receivedTime?: (google.protobuf.ITimestamp|null);

            /**
             * Creates a new FetchNode instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FetchNode instance
             */
            public static create(properties?: Trace.QueryPlanNode.IFetchNode): Trace.QueryPlanNode.FetchNode;

            /**
             * Encodes the specified FetchNode message. Does not implicitly {@link Trace.QueryPlanNode.FetchNode.verify|verify} messages.
             * @param message FetchNode message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encode(message: Trace.QueryPlanNode.IFetchNode, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FetchNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.FetchNode.verify|verify} messages.
             * @param message FetchNode message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encodeDelimited(message: Trace.QueryPlanNode.IFetchNode, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FetchNode message from the specified reader or buffer.
             * @param reader Reader or buffer to decode from
             * @param [length] Message length if known beforehand
             * @returns FetchNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.QueryPlanNode.FetchNode;

            /**
             * Decodes a FetchNode message from the specified reader or buffer, length delimited.
             * @param reader Reader or buffer to decode from
             * @returns FetchNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.QueryPlanNode.FetchNode;

            /**
             * Verifies a FetchNode message.
             * @param message Plain object to verify
             * @returns `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a plain object from a FetchNode message. Also converts values to other types if specified.
             * @param message FetchNode
             * @param [options] Conversion options
             * @returns Plain object
             */
            public static toObject(message: Trace.QueryPlanNode.FetchNode, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Converts this FetchNode to JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Properties of a FlattenNode. */
        interface IFlattenNode {

            /** FlattenNode responsePath */
            responsePath?: (Trace.QueryPlanNode.IResponsePathElement[]|null);

            /** FlattenNode node */
            node?: (Trace.IQueryPlanNode|null);
        }

        /** Represents a FlattenNode. */
        class FlattenNode implements IFlattenNode {

            /**
             * Constructs a new FlattenNode.
             * @param [properties] Properties to set
             */
            constructor(properties?: Trace.QueryPlanNode.IFlattenNode);

            /** FlattenNode responsePath. */
            public responsePath: Trace.QueryPlanNode.IResponsePathElement[];

            /** FlattenNode node. */
            public node?: (Trace.IQueryPlanNode|null);

            /**
             * Creates a new FlattenNode instance using the specified properties.
             * @param [properties] Properties to set
             * @returns FlattenNode instance
             */
            public static create(properties?: Trace.QueryPlanNode.IFlattenNode): Trace.QueryPlanNode.FlattenNode;

            /**
             * Encodes the specified FlattenNode message. Does not implicitly {@link Trace.QueryPlanNode.FlattenNode.verify|verify} messages.
             * @param message FlattenNode message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encode(message: Trace.QueryPlanNode.IFlattenNode, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified FlattenNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.FlattenNode.verify|verify} messages.
             * @param message FlattenNode message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encodeDelimited(message: Trace.QueryPlanNode.IFlattenNode, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a FlattenNode message from the specified reader or buffer.
             * @param reader Reader or buffer to decode from
             * @param [length] Message length if known beforehand
             * @returns FlattenNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.QueryPlanNode.FlattenNode;

            /**
             * Decodes a FlattenNode message from the specified reader or buffer, length delimited.
             * @param reader Reader or buffer to decode from
             * @returns FlattenNode
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.QueryPlanNode.FlattenNode;

            /**
             * Verifies a FlattenNode message.
             * @param message Plain object to verify
             * @returns `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a plain object from a FlattenNode message. Also converts values to other types if specified.
             * @param message FlattenNode
             * @param [options] Conversion options
             * @returns Plain object
             */
            public static toObject(message: Trace.QueryPlanNode.FlattenNode, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Converts this FlattenNode to JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }

        /** Properties of a ResponsePathElement. */
        interface IResponsePathElement {

            /** ResponsePathElement fieldName */
            fieldName?: (string|null);

            /** ResponsePathElement index */
            index?: (number|null);
        }

        /** Represents a ResponsePathElement. */
        class ResponsePathElement implements IResponsePathElement {

            /**
             * Constructs a new ResponsePathElement.
             * @param [properties] Properties to set
             */
            constructor(properties?: Trace.QueryPlanNode.IResponsePathElement);

            /** ResponsePathElement fieldName. */
            public fieldName: string;

            /** ResponsePathElement index. */
            public index: number;

            /** ResponsePathElement id. */
            public id?: ("fieldName"|"index");

            /**
             * Creates a new ResponsePathElement instance using the specified properties.
             * @param [properties] Properties to set
             * @returns ResponsePathElement instance
             */
            public static create(properties?: Trace.QueryPlanNode.IResponsePathElement): Trace.QueryPlanNode.ResponsePathElement;

            /**
             * Encodes the specified ResponsePathElement message. Does not implicitly {@link Trace.QueryPlanNode.ResponsePathElement.verify|verify} messages.
             * @param message ResponsePathElement message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encode(message: Trace.QueryPlanNode.IResponsePathElement, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Encodes the specified ResponsePathElement message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ResponsePathElement.verify|verify} messages.
             * @param message ResponsePathElement message or plain object to encode
             * @param [writer] Writer to encode to
             * @returns Writer
             */
            public static encodeDelimited(message: Trace.QueryPlanNode.IResponsePathElement, writer?: $protobuf.Writer): $protobuf.Writer;

            /**
             * Decodes a ResponsePathElement message from the specified reader or buffer.
             * @param reader Reader or buffer to decode from
             * @param [length] Message length if known beforehand
             * @returns ResponsePathElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Trace.QueryPlanNode.ResponsePathElement;

            /**
             * Decodes a ResponsePathElement message from the specified reader or buffer, length delimited.
             * @param reader Reader or buffer to decode from
             * @returns ResponsePathElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Trace.QueryPlanNode.ResponsePathElement;

            /**
             * Verifies a ResponsePathElement message.
             * @param message Plain object to verify
             * @returns `null` if valid, otherwise the reason why it is not
             */
            public static verify(message: { [k: string]: any }): (string|null);

            /**
             * Creates a plain object from a ResponsePathElement message. Also converts values to other types if specified.
             * @param message ResponsePathElement
             * @param [options] Conversion options
             * @returns Plain object
             */
            public static toObject(message: Trace.QueryPlanNode.ResponsePathElement, options?: $protobuf.IConversionOptions): { [k: string]: any };

            /**
             * Converts this ResponsePathElement to JSON.
             * @returns JSON object
             */
            public toJSON(): { [k: string]: any };
        }
    }
}

/** Properties of a ReportHeader. */
export interface IReportHeader {

    /** ReportHeader graphRef */
    graphRef?: (string|null);

    /** ReportHeader hostname */
    hostname?: (string|null);

    /** ReportHeader agentVersion */
    agentVersion?: (string|null);

    /** ReportHeader serviceVersion */
    serviceVersion?: (string|null);

    /** ReportHeader runtimeVersion */
    runtimeVersion?: (string|null);

    /** ReportHeader uname */
    uname?: (string|null);

    /** ReportHeader executableSchemaId */
    executableSchemaId?: (string|null);
}

/** Represents a ReportHeader. */
export class ReportHeader implements IReportHeader {

    /**
     * Constructs a new ReportHeader.
     * @param [properties] Properties to set
     */
    constructor(properties?: IReportHeader);

    /** ReportHeader graphRef. */
    public graphRef: string;

    /** ReportHeader hostname. */
    public hostname: string;

    /** ReportHeader agentVersion. */
    public agentVersion: string;

    /** ReportHeader serviceVersion. */
    public serviceVersion: string;

    /** ReportHeader runtimeVersion. */
    public runtimeVersion: string;

    /** ReportHeader uname. */
    public uname: string;

    /** ReportHeader executableSchemaId. */
    public executableSchemaId: string;

    /**
     * Creates a new ReportHeader instance using the specified properties.
     * @param [properties] Properties to set
     * @returns ReportHeader instance
     */
    public static create(properties?: IReportHeader): ReportHeader;

    /**
     * Encodes the specified ReportHeader message. Does not implicitly {@link ReportHeader.verify|verify} messages.
     * @param message ReportHeader message or plain object to encode
     * @param [writer] Writer to encode to
     * @returns Writer
     */
    public static encode(message: IReportHeader, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Encodes the specified ReportHeader message, length delimited. Does not implicitly {@link ReportHeader.verify|verify} messages.
     * @param message ReportHeader message or plain object to encode
     * @param [writer] Writer to encode to
     * @returns Writer
     */
    public static encodeDelimited(message: IReportHeader, writer?: $protobuf.Writer): $protobuf.Writer;

    /**
     * Decodes a ReportHeader message from the specified reader or buffer.
     * @param reader Reader or buffer to decode from
     * @param [length] Message length if known beforehand
     * @returns ReportHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ReportHeader;

    /**
     * Decodes a ReportHeader message from the specified reader or buffer, length delimited.
     * @param reader Reader or buffer to decode from
     * @returns ReportHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ReportHeader;

    /**
     * Verifies a ReportHeader message.
     * @param message Plain object to verify
     * @returns `null` if valid, otherwise the reason why it is not
     */
    public static verify(message: { [k: string]: any }): (string|null);

    /**
     * Creates a plain object from a ReportHeader message. Also converts values to other types if specified.
     * @param message ReportHeader
     * @param [options] Conversion options
     * @returns Plain object
     */
    public static toObject(message: ReportHeader, options?: $protobuf.IConversionOptions): { [k: string]: any };

    /**
     * Converts this ReportHeader to JSON.
     * @returns JSON object
     */
    public toJSON(): { [k: string]: any };
}

/** Properties of a PathErrorStats. */
e